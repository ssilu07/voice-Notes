package com.royals.voicenotes

import android.content.Context
import android.content.Intent
import android.net.Uri
import android.os.Environment
import androidx.core.content.FileProvider
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileWriter
import java.text.SimpleDateFormat
import java.util.*

object FileHelper {

    suspend fun exportNoteToFile(context: Context, note: Note): File? = withContext(Dispatchers.IO) {
        return@withContext try {
            val timestamp = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())
            val fileName = "voice_note_$timestamp.txt"

            // Use scoped storage for Android 10+
            val downloadsDir = if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.Q) {
                File(context.getExternalFilesDir(Environment.DIRECTORY_DOCUMENTS), "VoiceNotes")
            } else {
                Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
            }

            // Create directory if it doesn't exist
            if (!downloadsDir.exists()) {
                downloadsDir.mkdirs()
            }

            val file = File(downloadsDir, fileName)

            val fileWriter = FileWriter(file)
            fileWriter.write(buildExportContent(note))
            fileWriter.close()

            file
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    private fun buildExportContent(note: Note): String {
        return """
            â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
            â•‘                         VOICE NOTE                           â•‘
            â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            ðŸ“ Title: ${note.title}
            ðŸ•’ Created: ${note.timestamp}
            ðŸ“Š Word Count: ${note.content.split("\\s+".toRegex()).size} words
            ðŸ“± App: Voice Notes by Royals
            
            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CONTENT â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            ${note.content}
            
            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            Exported on: ${SimpleDateFormat("MMM dd, yyyy 'at' HH:mm:ss", Locale.getDefault()).format(Date())}
            
            Generated by Voice Notes App
            Â© ${Calendar.getInstance().get(Calendar.YEAR)} Royals
        """.trimIndent()
    }

    fun shareNote(context: Context, note: Note) {
        val shareText = """
            ðŸ“ ${note.title}
            
            ðŸ•’ Created: ${note.timestamp}
            ðŸ“Š ${note.content.split("\\s+".toRegex()).size} words
            
            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            ${note.content}
            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            Shared from Voice Notes App âœ¨
        """.trimIndent()

        val shareIntent = Intent().apply {
            action = Intent.ACTION_SEND
            type = "text/plain"
            putExtra(Intent.EXTRA_TEXT, shareText)
            putExtra(Intent.EXTRA_SUBJECT, "Voice Note: ${note.title}")
        }

        context.startActivity(Intent.createChooser(shareIntent, "Share Note"))
    }

    fun openFile(context: Context, file: File) {
        try {
            val uri = if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.N) {
                FileProvider.getUriForFile(context, "${context.packageName}.fileprovider", file)
            } else {
                Uri.fromFile(file)
            }

            val intent = Intent(Intent.ACTION_VIEW).apply {
                setDataAndType(uri, "text/plain")
                flags = Intent.FLAG_GRANT_READ_URI_PERMISSION
            }

            context.startActivity(Intent.createChooser(intent, "Open with"))
        } catch (e: Exception) {
            // Handle error - maybe show toast
            e.printStackTrace()
        }
    }

    suspend fun exportAllNotes(context: Context, notes: List<Note>): File? = withContext(Dispatchers.IO) {
        return@withContext try {
            val timestamp = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())
            val fileName = "all_voice_notes_$timestamp.txt"

            val downloadsDir = if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.Q) {
                File(context.getExternalFilesDir(Environment.DIRECTORY_DOCUMENTS), "VoiceNotes")
            } else {
                Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
            }

            if (!downloadsDir.exists()) {
                downloadsDir.mkdirs()
            }

            val file = File(downloadsDir, fileName)
            val fileWriter = FileWriter(file)

            fileWriter.write(buildAllNotesContent(notes))
            fileWriter.close()

            file
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    private fun buildAllNotesContent(notes: List<Note>): String {
        val sb = StringBuilder()

        sb.append("""
            â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
            â•‘                     ALL VOICE NOTES                          â•‘
            â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            ðŸ“Š Total Notes: ${notes.size}
            ðŸ“± Exported from: Voice Notes App
            ðŸ•’ Export Date: ${SimpleDateFormat("MMM dd, yyyy 'at' HH:mm:ss", Locale.getDefault()).format(Date())}
            
            â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
        """.trimIndent())

        notes.forEachIndexed { index, note ->
            sb.append("""
                
                â”Œâ”€ NOTE ${index + 1} â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                â”‚ ðŸ“ ${note.title}
                â”‚ ðŸ•’ ${note.timestamp}
                â”‚ ðŸ“Š ${note.content.split("\\s+".toRegex()).size} words
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                
                ${note.content}
                
                â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            """.trimIndent())
        }

        sb.append("""
            
            
            â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
            â•‘                         SUMMARY                              â•‘
            â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            ðŸ“Š Total Notes: ${notes.size}
            ðŸ“ Total Words: ${notes.sumOf { it.content.split("\\s+".toRegex()).size }}
            ðŸ•’ Export Completed: ${SimpleDateFormat("MMM dd, yyyy 'at' HH:mm:ss", Locale.getDefault()).format(Date())}
            
            Generated by Voice Notes App
            Â© ${Calendar.getInstance().get(Calendar.YEAR)} Royals
        """.trimIndent())

        return sb.toString()
    }

    fun getFileSize(file: File): String {
        val bytes = file.length()
        return when {
            bytes >= 1024 * 1024 -> String.format("%.1f MB", bytes / (1024.0 * 1024.0))
            bytes >= 1024 -> String.format("%.1f KB", bytes / 1024.0)
            else -> "$bytes bytes"
        }
    }

    fun validateFileName(fileName: String): String {
        return fileName.replace(Regex("[^a-zA-Z0-9._-]"), "_")
    }
}